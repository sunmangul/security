[GDB에 들어가기 앞서]
-fno-stack-protector 옵션을 포함하는 이유는 gcc가 스택을 보호하기 위해
canary라는 것을 함수내에서 사용하는 스택 프레임과 return address 사이에 넣음
버퍼 오버플로우가 발생해서 canary를 덮으면 프로그램을 종료해서 오류를 방지
>>SSP라고 함
아무튼 그래서 이런 보호기법을 해제하기 위해 -fno-stack-protector를 사용
반대로 모든 *프로시저에 보호기법을 적용하기 위해 -fstack-protector-all을 사용
*프로시저 : 특정한 로직을 처리하기만하고 반환하지 않는 서브 프로그램

[GDB 사용 이유]
오픈소스로 공개된 무료 디버거임(Doby is free!)
디버거는 코드에서 각 라인이 실행될 때 어떤 메모리 주소에 올라가고 과정을 보여주는 조흔거
콘솔기반이라 ELE파일과 같은 리눅스 기반 실행 파일을 동적으로 따라가며 분석할 때 좋음

[GDB 쓰는 법] >> 대충 어셈블리 어느정도하고 오셈 ㅇㅇ 진짜하고 오고 + register 종류나 이런거 공부해오셈
gdb ./tomato : gdb로 토마토에 붙음
set disassembly-flavor [명령어 형식] : 어셈블리 코드 문법을 설정하는 명령어로
intel과 at&t 둘 중 골라쓰면 된다
ex) set disassembly-falvor att
disas [함수 이름] : 함수의 어셈블리 코드를 보는 명령어
ex) disas main
b *[메모리주소] : breakpoint를 거는 명령어
>> 실행 중 "=>"이런 화살표가 보이면 잘 멈춘 것
info b : breakpoint의 정보를 열람할 수 있음
d [breakpoint 번호] : breakpoint를 삭제할 수 있는 명령어
run [매개변수] : gdb 내부에서 프로그램 실행
>> 명령행 인자로 main의 매개변수에 run 뒤에 쓴 매개변수가 넘어감
EIP : 레지스터의 종류로 다음 CPU가 할 일을 기억 했다가 이번 일이 끝나면 다음 할 일을 전달함
ni : 다음 *인스트럭션 실행
*인스트럭션 : CPU가 명령을 수행하기 위해 메모리 상에서 명령어를 읽어오는 과정\
x/{} [메모리 주소] : 메모리 출력
b : 1byte, h : 2byte, w : 4byte || x : 16진수, u : 10진수
진법이든 바이트든 옵션이 생략되면 이전에 사용한 옵션으로 출력

[Byte Ordering [Big Endian/ Little Endian]]
어셈블리 메모에 나와 있듯이 순서가 조금 이상함 0x12345678을 지정하면 
Intel CPU는 0x78563412 순서로 저장하는데 이를 Little Endian이라고 지칭함 이 같이 되는 이유는
낮은 자리 수 바이트 부터 앞에서 채워 나가기 때문에 발생함
하지만, gdb에서는 Big Endian 형시긍로 바이트 오더링을 하기 때문에 입력한 그대로 들어감
(네트워크 상에서는 Big Endian 형식의 바이트 오더링 사용)

특정 레지스터를 기준으로 메모리 값을 보고 싶으면 $표시와 레지스터 이름을 입력하여
출력해볼 수 있음
ex) x/wx $ebp
그리고 info reg $[register_name] 혹은 ir $[register_name]을 통하여 레지스터 정보를
출력할 수 있고 따로 이름을 적지 않는다면 모든(?) 레지스터의 정보가 출력 됨\

[대충 STACK 관련 내용]
┌──────────────────────────────────────────────────────┐
│            Register associated with Stack            │
├───────────┬──────────────────────────────────────────┤ 
│    EBP    │ 스택의 가장 밑바닥의 주소를 가진 레지스터 │
├───────────┼──────────────────────────────────────────┤
│    ESP    │  스택의 가장 상단의 주소를 가진 레지스터  │
├───────────┼──────────────────────────────────────────┤
│    EIP    │ 현재 실행중인 명령의 주소를 가진 레지스터 │
└───────────┴──────────────────────────────────────────┘

push ebp
mov ebp, esp
>> 함수 가 실행 될 때, 그 전의 ebp(sfp)를 스택에 push 하고 현재 esp를 ebp에 저장하여
새로운 ebp를 생성하는 뜻으로 스택(프레임)이 생성되는 과정임

